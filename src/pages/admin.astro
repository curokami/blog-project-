---
// src/pages/admin.astro
// Astro公式ドキュメントに基づいた実装: https://docs.astro.build/ja/guides/cms/decap-cms/
---

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex" />
  <title>Content Manager</title>
  <!-- Decap CMSの設定ファイルを読み込む -->
  <link rel="cms-config-url" href="/admin/config.yml" />
</head>
<body>
  <!-- Decap CMSのマウントポイント -->
  <div id="nc-root"></div>
  
  <!-- Decap CMSスクリプトをCDNから読み込む（公式推奨方法） -->
  <!-- 参考リポジトリと同じバージョンを使用 -->
  <script src="https://unpkg.com/decap-cms@3.3.3/dist/decap-cms.js"></script>
  
  <script>
    // グローバルなCustomAuthインスタンスへの参照を保持
    let globalCustomAuthInstance = null;
    
    // 認証メッセージをキューに保存（authenticate()が呼び出される前にpostMessageが届いた場合の対策）
    let pendingAuthMessages = [];
    
    // ページロード時にグローバルなmessageイベントリスナーを設定（デバッグ用）
    window.addEventListener("message", (event) => {
      console.log('=== [GLOBAL] Message event received ===');
      console.log('Event origin:', event.origin);
      console.log('Current origin:', window.location.origin);
      console.log('Event data:', event.data);
      console.log('Event data type:', event.data?.type);
      console.log('Event source:', event.source);
      console.log('Timestamp:', new Date().toISOString());
      
      // CustomAuthインスタンスが存在する場合、authCallbackも呼び出す
      console.log('=== [GLOBAL] Checking CustomAuth instance ===');
      console.log('globalCustomAuthInstance exists:', !!globalCustomAuthInstance);
      console.log('globalCustomAuthInstance type:', typeof globalCustomAuthInstance);
      console.log('authCallback exists:', !!globalCustomAuthInstance?.authCallback);
      console.log('authCallback type:', typeof globalCustomAuthInstance?.authCallback);
      
      // エラーメッセージの処理（CustomAuthインスタンスがなくても処理できるように）
      if (event.data && event.data.type === 'authorization_error') {
        console.error('=== [GLOBAL] Authorization error received ===');
        console.error('Error:', event.data.payload?.error);
        if (globalCustomAuthInstance && typeof globalCustomAuthInstance.authCallback === 'function') {
          console.log('=== [GLOBAL] Forwarding error to authCallback ===');
          try {
            globalCustomAuthInstance.authCallback(event);
            console.log('✓ [GLOBAL] Error forwarded to authCallback');
          } catch (error) {
            console.error('✗ [GLOBAL] Error in authCallback:', error);
          }
        }
        return;
      }
      
      if (globalCustomAuthInstance && typeof globalCustomAuthInstance.authCallback === 'function') {
        console.log('=== [GLOBAL] Forwarding to authCallback ===');
        try {
          globalCustomAuthInstance.authCallback(event);
          console.log('✓ [GLOBAL] authCallback completed without errors');
        } catch (error) {
          console.error('✗ [GLOBAL] Error in authCallback:', error);
          console.error('Error message:', error.message);
          console.error('Error stack:', error.stack);
        }
      } else {
        console.warn('⚠ [GLOBAL] CustomAuth instance not available yet');
        console.warn('⚠ [GLOBAL] This might mean authenticate() has not been called yet');
        console.warn('⚠ [GLOBAL] Event data:', event.data);
        
        // CustomAuthインスタンスが利用可能になるまで待ってから再試行
        // これは、postMessageがauthenticate()の呼び出しより前に届いた場合の対策
        if (event.data && (event.data.type === 'authorization_response' || event.data.type === 'authorization_error')) {
          console.log('=== [GLOBAL] Saving message to queue (waiting for CustomAuth instance) ===');
          pendingAuthMessages.push(event);
          console.log('Pending messages count:', pendingAuthMessages.length);
          
          console.log('=== [GLOBAL] Retrying after delay (waiting for CustomAuth instance) ===');
          let retryCount = 0;
          const maxRetries = 20; // 20回に増やす（4秒間待つ）
          const retryInterval = setInterval(() => {
            retryCount++;
            console.log(`=== [GLOBAL] Retry attempt ${retryCount}/${maxRetries} ===`);
            console.log('globalCustomAuthInstance exists:', !!globalCustomAuthInstance);
            
            if (globalCustomAuthInstance && typeof globalCustomAuthInstance.authCallback === 'function') {
              console.log('✓ [GLOBAL] CustomAuth instance found, processing queued messages');
              clearInterval(retryInterval);
              
              // キューに保存されたメッセージを処理
              while (pendingAuthMessages.length > 0) {
                const queuedEvent = pendingAuthMessages.shift();
                console.log('=== [GLOBAL] Processing queued message ===');
                try {
                  globalCustomAuthInstance.authCallback(queuedEvent);
                  console.log('✓ [GLOBAL] Queued message processed successfully');
                } catch (error) {
                  console.error('✗ [GLOBAL] Error processing queued message:', error);
                }
              }
            } else if (retryCount >= maxRetries) {
              console.error('✗ [GLOBAL] Max retries reached, CustomAuth instance still not available');
              console.error('✗ [GLOBAL] Pending messages count:', pendingAuthMessages.length);
              clearInterval(retryInterval);
            }
          }, 200); // 200msごとに再試行
        }
      }
    }, false);
    
    console.log('=== Page loaded, global message listener registered ===');
    
    // カスタム認証プロバイダー（GitHub OAuth用）
    class CustomAuth {
      constructor(auth_url = "/api/auth") {
        console.log('=== [CustomAuth] Constructor called ===');
        console.log('Auth URL:', auth_url);
        console.log('CustomAuth instance (this):', this);
        
        this.auth_url = auth_url;
        this.authWindow = null;
        this.authPromise = null;
        this.token = null;
        this.checkClosedInterval = null;
        
        // グローバル変数にインスタンスを保存（コンストラクタ時点でも保存）
        globalCustomAuthInstance = this;
        console.log('✓ [CustomAuth] Instance saved to globalCustomAuthInstance in constructor');
      }

      authenticate() {
        console.log('=== [CustomAuth] authenticate() called ===');
        console.log('CustomAuth instance:', this);
        console.log('Auth URL:', this.auth_url);
        
        // グローバル変数にインスタンスを保存（グローバルリスナーから呼び出せるように）
        globalCustomAuthInstance = this;
        console.log('✓ [CustomAuth] Instance saved to global variable');
        
        // キューに保存されたメッセージを処理（postMessageがauthenticate()より前に届いた場合）
        if (pendingAuthMessages.length > 0) {
          console.log(`=== [CustomAuth] Processing ${pendingAuthMessages.length} queued message(s) ===`);
          while (pendingAuthMessages.length > 0) {
            const queuedEvent = pendingAuthMessages.shift();
            console.log('=== [CustomAuth] Processing queued message ===');
            try {
              this.authCallback(queuedEvent);
              console.log('✓ [CustomAuth] Queued message processed successfully');
            } catch (error) {
              console.error('✗ [CustomAuth] Error processing queued message:', error);
            }
          }
        }
        
        this.authPromise = null;
        
        if (this.checkClosedInterval) {
          clearInterval(this.checkClosedInterval);
          this.checkClosedInterval = null;
        }
        
        return new Promise((resolve, reject) => {
          this.authPromise = { resolve, reject };
          
          const authCallback = this.authCallback.bind(this);
          const authWindowRef = this; // thisの参照を保持
          
          // グローバルなmessageイベントリスナーを設定（デバッグ用）
          const globalMessageHandler = (event) => {
            console.log('=== Global message event received ===');
            console.log('Event origin:', event.origin);
            console.log('Current origin:', window.location.origin);
            console.log('Event data:', event.data);
            console.log('Event data type:', event.data?.type);
            console.log('Event source:', event.source);
            console.log('Auth window reference:', authWindowRef.authWindow);
            console.log('Is from opener:', event.source === authWindowRef.authWindow);
          };
          
          // 既存のリスナーを削除してから追加
          window.removeEventListener("message", authCallback, false);
          window.removeEventListener("message", globalMessageHandler, false);
          window.addEventListener("message", authCallback, false);
          window.addEventListener("message", globalMessageHandler, false);
          
          console.log('=== Opening auth window ===');
          console.log('Auth URL:', `${this.auth_url}?provider=github&site_id=${window.location.host}`);
          console.log('Current origin:', window.location.origin);
          console.log('Message event listener registered');
          
          const auth_url = `${this.auth_url}?provider=github&site_id=${window.location.host}`;
          this.authWindow = window.open(auth_url, "auth", "width=600,height=600");
          
          if (!this.authWindow) {
            reject(new Error("ポップアップがブロックされました。ポップアップブロッカーを無効にしてください。"));
            return;
          }
          
          console.log('Auth window opened:', this.authWindow);
          
          this.checkClosedInterval = setInterval(() => {
            if (this.authWindow?.closed) {
              if (this.checkClosedInterval) {
                clearInterval(this.checkClosedInterval);
                this.checkClosedInterval = null;
              }
              if (this.authPromise) {
                window.removeEventListener("message", authCallback, false);
                window.removeEventListener("message", globalMessageHandler, false);
                this.authPromise.reject(new Error("認証ウィンドウが閉じられました"));
                this.authPromise = null;
              }
            }
          }, 1000);
        });
      }

      authCallback(event) {
        console.log('=== authCallback: Received message event ===');
        console.log('Event origin:', event.origin);
        console.log('Expected origin:', window.location.origin);
        console.log('Event data:', event.data);
        console.log('Event data type:', event.data?.type);
        console.log('Event data keys:', event.data ? Object.keys(event.data) : 'no data');
        console.log('Has payload:', !!event.data?.payload);
        console.log('Has token:', !!event.data?.payload?.token);
        console.log('Event source:', event.source);
        console.log('Auth window:', this.authWindow);
        console.log('Is from auth window:', event.source === this.authWindow);
        
        if (event.origin !== window.location.origin) {
          console.warn(`✗ Ignored message from different origin: ${event.origin} (expected: ${window.location.origin})`);
          return;
        }
        
        console.log('✓ Origin check passed');
        
        // エラーメッセージの処理
        if (event.data && event.data.type === 'authorization_error') {
          console.error('✗ Authorization error received');
          console.error('Error:', event.data.payload?.error);
          
          if (this.checkClosedInterval) {
            clearInterval(this.checkClosedInterval);
            this.checkClosedInterval = null;
            console.log('✓ Closed interval cleared');
          }
          
          if (this.authPromise) {
            console.log('✗ Rejecting auth promise with error');
            this.authPromise.reject(new Error(event.data.payload?.error || '認証エラーが発生しました'));
            this.authPromise = null;
          } else {
            console.warn('⚠ No auth promise to reject');
          }
          
          this.cleanup();
          console.log('✓ Cleanup completed after error');
          return;
        }
        
        // 成功レスポンスの処理
        if (event.data && event.data.type === 'authorization_response' && event.data.payload && event.data.payload.token) {
          console.log('✓ Valid authorization response received');
          const token = event.data.payload.token;
          console.log('Token (first 10 chars):', token ? token.substring(0, 10) + '...' : 'no token');
          
          if (this.checkClosedInterval) {
            clearInterval(this.checkClosedInterval);
            this.checkClosedInterval = null;
            console.log('✓ Closed interval cleared');
          }
          
          this.token = event.data.payload.token;
          console.log('✓ Token stored, authentication successful');
          
          if (this.authPromise) {
            console.log('✓ Resolving auth promise');
            this.authPromise.resolve(true);
            this.authPromise = null;
          } else {
            console.warn('⚠ No auth promise to resolve');
          }
          
          this.cleanup();
          console.log('✓ Cleanup completed');
        } else {
          console.warn('✗ Invalid message format:', {
            hasData: !!event.data,
            type: event.data?.type,
            hasPayload: !!event.data?.payload,
            hasToken: !!event.data?.payload?.token,
            fullEventData: event.data
          });
        }
      }

      cleanup() {
        if (this.authWindow) {
          this.authWindow.close();
        }
        window.removeEventListener("message", this.authCallback.bind(this));
      }

      async getUser() {
        if (!this.token) {
          console.error("getUser called but no token available");
          throw new Error("Not authenticated");
        }

        console.log("Fetching user info from GitHub API");
        const res = await fetch("https://api.github.com/user", {
          headers: {
            Authorization: `Bearer ${this.token}`,
            Accept: "application/vnd.github.v3+json",
          },
        });

        if (!res.ok) {
          console.error("GitHub API error:", res.status, res.statusText);
          const err = await res.json();
          console.error("GitHub API error details:", err);
          throw err;
        }

        const data = await res.json();
        console.log("User info retrieved:", data.login);
        return {
          name: data.name || data.login,
          login: data.login,
          avatar_url: data.avatar_url,
        };
      }

      logout() {
        this.token = null;
        return Promise.resolve();
      }

      getToken() {
        return Promise.resolve(this.token);
      }
    }

    // Decap CMSが読み込まれるのを待つ
    let cmsInitialized = false;
    let backendRegistered = false;
    
    function waitForCMS() {
      const CMS = window.CMS || window.DecapCMS || window.NETLIFY_CMS;
      
      if (!CMS) {
        console.log('Waiting for Decap CMS...');
        setTimeout(waitForCMS, 100);
        return;
      }
      
      if (cmsInitialized) {
        return; // 既に初期化済みの場合は何もしない
      }
      
      console.log('✓ Decap CMS loaded from CDN');
      console.log('CMS object:', CMS);
      console.log('Available methods:', Object.keys(CMS));
      
      // マウントポイントが存在することを確認
      const mountPoint = document.getElementById('nc-root');
      if (!mountPoint) {
        console.error('✗ Mount point #nc-root not found');
        setTimeout(waitForCMS, 100);
        return;
      }
      
      // マウントポイントをクリア（DOMエラーを回避）
      mountPoint.innerHTML = '';
      
      // カスタムバックエンドを登録（CMS.init()の前に実行する必要がある）
      // Decap CMSが既にデフォルトのGitHubバックエンドを登録している可能性があるため、
      // 既存のバックエンドを削除してからカスタムバックエンドを登録する
      console.log('=== Backend registration process ===');
      console.log('CMS.backends before:', CMS.backends);
      console.log('CMS.registry exists:', !!CMS.registry);
      console.log('CMS.registry.backends exists:', !!(CMS.registry && CMS.registry.backends));
      
      // Decap CMSの内部レジストリから既存のバックエンドを削除
      if (CMS.registry && CMS.registry.backends) {
        console.log('CMS.registry.backends before:', CMS.registry.backends);
        if (CMS.registry.backends.github) {
          console.log('⚠ Existing github backend found in registry, attempting to delete...');
          delete CMS.registry.backends.github;
          console.log('✓ Deleted existing github backend from registry');
        }
      }
      
      // 既存のバックエンドを削除する方法を試す
      if (CMS.backends && CMS.backends.github) {
        console.log('⚠ Existing github backend found, attempting to override...');
        delete CMS.backends.github;
        console.log('✓ Deleted existing github backend');
      }
      
      // バックエンドを登録
      if (typeof CMS.registerBackend === 'function') {
        console.log('Registering custom backend...');
        console.log('CustomAuth class:', CustomAuth);
        console.log('CustomAuth methods:', Object.getOwnPropertyNames(CustomAuth.prototype));
        try {
          // エラーを無視して強制的に登録を試みる
          CMS.registerBackend("github", CustomAuth);
          backendRegistered = true;
          console.log('✓ Custom backend registered successfully');
          
          // バックエンドが正しく登録されたか確認
          if (CMS.backends && CMS.backends.github) {
            console.log('✓ Backend confirmed in CMS.backends.github');
            console.log('Registered backend:', CMS.backends.github);
            console.log('Registered backend === CustomAuth:', CMS.backends.github === CustomAuth);
          } else {
            console.warn('⚠ Backend not found in CMS.backends.github after registration');
            // 代替方法: CMSオブジェクトに直接設定
            if (!CMS.backends) {
              CMS.backends = {};
            }
            CMS.backends.github = CustomAuth;
            console.log('✓ Backend set directly via CMS.backends.github');
            console.log('Backend confirmed:', CMS.backends.github);
          }
        } catch (error) {
          // 既に登録されている場合は警告を無視して、直接設定を試みる
          if (error.message && error.message.includes('already registered')) {
            console.log('⚠ Backend already registered, attempting direct override...');
            if (!CMS.backends) {
              CMS.backends = {};
            }
            CMS.backends.github = CustomAuth;
            backendRegistered = true;
            console.log('✓ Backend overridden directly via CMS.backends.github');
            console.log('Backend confirmed:', CMS.backends.github);
          } else {
            console.error('✗ Failed to register custom backend:', error);
            console.error('Error details:', error.message, error.stack);
            // エラーが発生しても直接設定を試みる
            if (!CMS.backends) {
              CMS.backends = {};
            }
            CMS.backends.github = CustomAuth;
            backendRegistered = true;
            console.log('✓ Backend set directly after error');
          }
        }
      } else {
        console.warn('⚠ CMS.registerBackend is not available, using direct assignment');
        // 代替方法: CMSオブジェクトに直接設定
        if (!CMS.backends) {
          CMS.backends = {};
        }
        CMS.backends.github = CustomAuth;
        backendRegistered = true;
        console.log('✓ Custom backend registered via direct assignment');
        console.log('Backend confirmed:', CMS.backends.github);
      }
      
      console.log('CMS.backends after registration:', CMS.backends);
      
      // CMS.init()が利用可能になるまで待つ
      if (typeof CMS.init !== 'function') {
        console.log('Waiting for CMS.init...');
        setTimeout(waitForCMS, 100);
        return;
      }
      
      // CMSを初期化
      // config.ymlが自動的に読み込まれるので、CMS.init()を引数なしで呼び出す
      console.log('Initializing CMS...');
      try {
        // 参考リポジトリの実装に基づき、config.ymlから自動的に設定を読み込む
        CMS.init();
        cmsInitialized = true;
        console.log('✓ Decap CMS initialized successfully');
        
        // CMS.init()の直後に、バックエンドが強制的に設定されているか確認
        console.log('=== Immediate post-init check ===');
        console.log('CMS.backends immediately after init:', CMS.backends);
        console.log('CMS.backends.github immediately after init:', CMS.backends?.github);
        
        // バックエンドが設定されていない場合、強制的に設定
        if (!CMS.backends || !CMS.backends.github || CMS.backends.github !== CustomAuth) {
          console.log('⚠ Backend not set correctly after CMS.init(), forcing override...');
          if (!CMS.backends) {
            CMS.backends = {};
          }
          CMS.backends.github = CustomAuth;
          console.log('✓ Backend forced after CMS.init()');
        }
        
        // 初期化後に再度バックエンドを登録（CMS.init()の後に必要かもしれない）
        setTimeout(() => {
          console.log('=== Post-init backend registration ===');
          if (typeof CMS.registerBackend === 'function') {
            try {
              CMS.registerBackend("github", CustomAuth);
              console.log('✓ Backend re-registered after CMS.init()');
            } catch (error) {
              console.warn('⚠ Backend re-registration failed:', error.message);
            }
          }
          
          // バックエンドが認識されているか確認
          console.log('=== Post-init backend check ===');
          console.log('CMS.backends:', CMS.backends);
          console.log('CMS.backends.github:', CMS.backends?.github);
          console.log('CMS.backends.github === CustomAuth:', CMS.backends?.github === CustomAuth);
          
          // Decap CMSの内部状態を確認
          console.log('CMS.store exists:', !!CMS.store);
          console.log('CMS.store.getState exists:', !!(CMS.store && CMS.store.getState));
          
          if (CMS.store && CMS.store.getState) {
            try {
              const state = CMS.store.getState();
              console.log('CMS store state:', state);
              console.log('CMS store state keys:', Object.keys(state || {}));
              
              if (state.config && state.config.backend) {
                console.log('CMS config backend:', state.config.backend);
                console.log('CMS config backend name:', state.config.backend.name);
              }
              
              // バックエンドインスタンスを確認
              if (state.backend) {
                console.log('CMS backend state:', state.backend);
                console.log('CMS backend state keys:', Object.keys(state.backend || {}));
                if (state.backend.backendClass) {
                  console.log('CMS backend instance:', state.backend.backendClass);
                  console.log('CMS backend instance === CustomAuth:', state.backend.backendClass === CustomAuth);
                }
              }
            } catch (error) {
              console.error('✗ Error accessing CMS store state:', error);
            }
          } else {
            console.warn('⚠ CMS.store or CMS.store.getState not available');
          }
          
          // Decap CMSのレジストリを確認
          if (CMS.registry && CMS.registry.backends) {
            console.log('CMS.registry.backends:', CMS.registry.backends);
            console.log('CMS.registry.backends.github:', CMS.registry.backends.github);
          }
          
          // Decap CMSがバックエンドインスタンスを作成するタイミングを監視
          // Proxyを使用して、CMS.backends.githubへのアクセスを監視
          if (CMS.backends && CMS.backends.github) {
            const originalBackend = CMS.backends.github;
            
            // CustomAuthクラスのプロトタイプを監視して、インスタンス作成を検出
            const originalAuthenticate = CustomAuth.prototype.authenticate;
            CustomAuth.prototype.authenticate = function(...args) {
              console.log('=== [PROXY] authenticate() called on CustomAuth instance ===');
              console.log('CustomAuth instance:', this);
              
              // グローバル変数にインスタンスを保存
              globalCustomAuthInstance = this;
              console.log('✓ [PROXY] Instance saved to globalCustomAuthInstance');
              
              // キューに保存されたメッセージを処理
              if (pendingAuthMessages.length > 0) {
                console.log(`=== [PROXY] Processing ${pendingAuthMessages.length} queued message(s) ===`);
                // authenticate()が完了するのを待ってから処理
                setTimeout(() => {
                  while (pendingAuthMessages.length > 0) {
                    const queuedEvent = pendingAuthMessages.shift();
                    console.log('=== [PROXY] Processing queued message ===');
                    try {
                      this.authCallback(queuedEvent);
                      console.log('✓ [PROXY] Queued message processed successfully');
                    } catch (error) {
                      console.error('✗ [PROXY] Error processing queued message:', error);
                    }
                  }
                }, 100);
              }
              
              // 元のメソッドを呼び出す
              return originalAuthenticate.apply(this, args);
            };
            
            console.log('✓ Proxy installed on CustomAuth.prototype.authenticate');
          }
        }, 1000);
      } catch (error) {
        console.error('✗ Failed to initialize CMS:', error);
        console.error('Error details:', error.message, error.stack);
        // エラーが発生しても再試行しない（無限ループを防ぐ）
        cmsInitialized = true;
      }
    }
    
    // DOMが完全に読み込まれてから初期化を開始
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(waitForCMS, 200);
      });
    } else {
      setTimeout(waitForCMS, 200);
    }
  </script>
</body>
</html>


